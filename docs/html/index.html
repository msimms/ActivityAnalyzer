<!DOCTYPE html>
<html lang="en-US">

<head>

<title>Activity Analyzer</title>

<link rel="stylesheet" type="text/css" href="../css/normalize.css">
<link rel="stylesheet" type="text/css" href="../css/site.css">

<meta charset="UTF-8">
<meta name="description" content="Analyzes GPX, TCX, and FIT files. Allows for file comparison and file splitting. Automatically identifies intervals. Allows files to be split and exported. Does all processing in browser.">
<meta name="keywords" content="gpx tcx fit analyze analysis split merge export">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />

<link rel="shortcut icon" href="../images/favicon.ico" >

</head>

<body>

<style type="text/css">
    html { height: 100% }
    body { height: 100%; margin: 0; padding: 0 }
    div { margin: 0px }
    #map_canvas { height: 75% }

    div.bar
    {
        display: inline-block;
        width: 20px;
        height: 75px;	/* Gets overriden by D3-assigned height below */
        background-color: teal;
    }

    .axis path,
    .axis line
    {
        fill: none;
        stroke: #000;
        stroke-width: 1;
        shape-rendering: crispEdges;
    }
    .axis-grid line {
        fill: none;
        stroke: #def;
        stroke-width: 1;
    }
</style>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.js" integrity="sha512-n/4gHW3atM3QqRcbCn6ewmpxcLAHGaDjpEBu4xZd47N0W2oQ+6q7oc3PXstrJYXcbNU1OHdQ1T7pAP+gi5Yu8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" integrity="sha256-KM512VNnjElC30ehFwehXjx1YCHPiQkOPmqnrWtpccM=" crossorigin="anonymous"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js" integrity="sha512-RJJ1NNC88QhN7dwpCY8rm/6OxI+YdQP48DrLGe/eSAd+n+s1PXwQkkpzzAgoJe4cZFW2GALQoxox61gSY2yQfg==" crossorigin="anonymous"></script>

<script type="text/javascript">
    /// @function pad
    /// Utility function for padding a number with leading zeroes.
    function pad(num, size)
    {
        var s = "000000000" + num;
        return s.substr(s.length - size);
    }

    /// @function convert_seconds_to_hours_mins_secs
    /// Converts seconds to HH:MM:SS format.
    function convert_seconds_to_hours_mins_secs(seconds_in)
    {
        seconds = seconds_in % 60;
        minutes = Math.trunc(seconds_in / 60);
        hours = Math.trunc(minutes / 60);
        minutes = Math.trunc(minutes % 60);
        out_str = pad(hours.toFixed(0), 2) + ":" + pad(minutes.toFixed(0), 2) + ":" + pad(seconds.toFixed(0), 2);
        return out_str;
    }

    /// @function unix_time_ms_to_local_string
    function unix_time_ms_to_local_string(unix_time)
    {
        let date = new Date(unix_time);
        return date.toLocaleString();
    }

    /// @function unix_time_ms_to_local_date_string
    function unix_time_ms_to_local_date_string(unix_time)
    {
        let date = new Date(unix_time);
        return date.toLocaleDateString();
    }

    /// @function convert_distance_to_unit_system_str
    /// Converts meters to whatever the preferred units are and formats it as a string.
    function convert_distance_to_unit_system_str(unit_system, meters_traveled)
    {
        if (unit_system == "Metric")
        {
            let km = meters_traveled / 1000.0;
            return km.toFixed(2).toString() + " kms";
        }
        let miles = meters_traveled * 0.000621371;
        return miles.toFixed(2).toString() + " miles";
    }

    /// @function convert_vertical_distance_to_unit_system_str
    /// Converts meters to whatever the preferred units are and formats it as a string.
    function convert_vertical_distance_to_unit_system_str(unit_system, meters_climbed)
    {
        if (unit_system == "Metric")
        {
            return meters_climbed.toFixed(2).toString() + " meters";
        }
        let feet = meters_climbed * 3.28084;
        return feet.toFixed(2).toString() + " feet";
    }

    /// @function convert_speed_to_unit_system_str
    /// Converts meters/second to whatever the preferred units are and formats it as a string.
    function convert_speed_to_unit_system_str(unit_system, speed)
    {
        if (unit_system == "Metric")
        {
            let km = speed * 3.6;
            return km.toFixed(2).toString() + " km/hr";
        }
        let miles = speed * 2.23694;
        return miles.toFixed(2).toString() + " miles/hr";
    }

    /// @function convert_pace_to_unit_system_str
    /// Converts meters/minute to whatever the preferred units are and formats it as a string.
    function convert_pace_to_unit_system_str(unit_system, pace)
    {
        if (unit_system == "Metric")
        {
            let km = pace / 1000.0;
            return km.toFixed(2).toString() + " mins/km";
        }
        let miles = pace * 609.344;
        return miles.toFixed(2).toString() + " mins/mile";
    }

    /// @function append_to_table_row
    function append_to_table_row(row, text)
    {
        let cell = row.insertCell();
        let a = document.createElement('a');
        let link_text = document.createTextNode(text);

        a.appendChild(link_text);
        a.title = text;

        cell.appendChild(a);
    }

    /// @function append_to_table
    function append_to_table(table, name, value)
    {
        let new_row = table.insertRow();

        append_to_table_row(new_row, name);
        append_to_table_row(new_row, value);
    }

    /// @function on_units_changed
    function on_units_changed()
    {
        let units = document.getElementById('units').value;
        document.cookie = "units=" + units;
    }

    /// @function on_export_format_changed
    function on_export_format_changed()
    {
        let export_format = document.getElementById('export_format').value;
        document.cookie = "export_format=" + export_format;
    }

    /// @function on_export_style_changed
    function on_export_style_changed()
    {
        let section = document.getElementById('export_splits');

        if (document.getElementById('export_style').value == "MultipleFiles")
        {
            section.style = "display: block;";
        }
        else
        {
            section.style = "display: none;";
        }
    }

    /// @function normalize_split_times
    function normalize_split_times(split_data)
    {
        let new_split_data = [];
        let last_split_value = 0;

        for (let i = 0; i < split_data.length; ++i)
        {
            let new_split_value = split_data[i] - last_split_value;

            last_split_value = split_data[i];
            new_split_data.push(new_split_value);
        }
        return new_split_data;
    }

    /// @function convert_speed_graph_to_display_units
    function convert_speed_graph_to_display_units(unit_system, speed_list)
    {
        let new_speed_list = [];
        let is_metric = (unit_system == "Metric");
        let max = 0.0;

        // Speed is in meters/second.
        for (let data_point in speed_list)
        {
            let date = speed_list[data_point].date;
            let speed = speed_list[data_point].value;
            let value = 0.0;

            if (is_metric)
                value = speed * 3.6;
            else
                value = speed * 2.23694;
            if (value > max)
                max = value;
            new_speed_list.push({date, value}); 
        }
        return [ new_speed_list, max ];
    }

    /// @function convert_speed_graph_to_pace_graph
    function convert_speed_graph_to_pace_graph(unit_system, speed_list)
    {
        let pace_list = [];
        let is_metric = (unit_system == "Metric");
        let min = 0.0;

        // Speed is in meters/second.
        for (let data_point in speed_list)
        {
            let date = speed_list[data_point].date;
            let speed = speed_list[data_point].value;
            let value = 0.0;

            if (speed > 1.25)
            {
                if (is_metric)
                    value = 16.6666667 / speed;
                else
                    value = 26.8224 / speed;
                if (min < 0.1 || value < min)
                    min = value;
            }
            else
                value = 0.0;
            pace_list.push({date, value});
        }
        return [ pace_list, min ];
    }

    /// @function compute_grade_adjusted_pace
    function compute_grade_adjusted_pace(gradient_list, time_pace_data)
    {
        let gap_list = time_pace_data.map(function(x, i) {
            let gradient = gradient_list[i];
            let cost = (155.4 * (Math.pow(gradient, 5))) - (30.4 * Math.pow(gradient, 4)) - (43.4 * Math.pow(gradient, 3)) - (46.3 * (gradient * gradient)) - (19.5 * gradient) + 3.6;
            let value = x.value + (cost - 3.6) / 3.6;

            if (value < 0.0)
                value = 0.0;

            return {"date": new Date(x.date), "value": value};
        });
        return gap_list;
    }
</script>

<!-- Note the usage of `type=module` here as this is an ES6 module -->
<script type="module">
    import init, { greet, analyze_gpx, analyze_tcx, analyze_fit, export_data, merge } from '../../activity-analyzer/pkg/activity_analyzer.js';

    async function run() {
        await init();
    }

    let reports = [];
    let current_file_num = 0;

    let intervals_graph = null;
    let power_intervals_graph = null;
    let speed_graph = null;
    let pace_graph = null;
    let gap_pace_graph = null;
    let power_graph = null;
    let cadence_graph = null;
    let hr_graph = null;
    let altitude_graph = null;
    let temp_graph = null;

    let graph_start_time_ms = null;
    let graph_end_time_ms = null;
    let max_power = null;
    let max_cadence = null;
    let max_hr = null;
    let max_altitude = null;

    function find_graph_extents(json_data)
    {
        let start_time_ms = json_data["Start Time (ms)"];
        let end_time_ms = json_data["End Time (ms)"];

        if (graph_start_time_ms == null || start_time_ms < graph_start_time_ms)
            graph_start_time_ms = start_time_ms
        if (graph_end_time_ms == null || end_time_ms > graph_end_time_ms)
            graph_end_time_ms = end_time_ms

        if (json_data["Maximum Power"] > 0)
        {
            let temp = json_data["Maximum Power"];

            if (max_power == null || temp > max_power)
                max_power = temp;
        }
        if (json_data["Maximum Cadence"] > 0)
        {
            let temp = json_data["Maximum Cadence"];

            if (max_cadence == null || temp > max_cadence)
                max_cadence = temp;
        }
        if (json_data["Maximum Heart Rate"] > 0)
        {
            let temp = json_data["Maximum Heart Rate"];

            if (max_hr == null || temp > max_hr)
                max_hr = temp;
        }
    }

    function render(json_data, file_num, total_num_files)
    {
        let fill = total_num_files == 1;
        let map_colors = ["red", "green", "blue"];
        let map_color = map_colors[(file_num - 1) % map_colors.length];

        // Create the table for this file's analysis summary.
        let analysis_section = document.getElementById('analysis_section');
        let analysis_div = document.createElement("div");
        let analysis_title = document.createElement("h1");
        let analysis_table = document.createElement("table");

        if (total_num_files > 1)
            analysis_title.innerHTML = "Analysis of File " + file_num.toString();
        else
            analysis_title.innerHTML = "Analysis";

        analysis_div.appendChild(analysis_title);
        analysis_div.appendChild(analysis_table);
        analysis_section.appendChild(analysis_div);

        // Which unit system are we using.
        let units = document.getElementById('units').value;
        let speed_units = "";
        let pace_units = "";

        if (units == "Metric")
        {
            speed_units = "kph";
            pace_units = "mins/km";
        }
        else
        {
            speed_units = "mph";
            pace_units = "mins/mile";
        }

        let start_time_ms = json_data["Start Time (ms)"];
        let end_time_ms = json_data["End Time (ms)"];
        let elapsed_time = json_data["Elapsed Time"];
        let distance_meters = json_data["Total Distance"];
        let vertical_distance = json_data["Total Vertical Distance"];

        if (graph_start_time_ms == null || start_time_ms < graph_start_time_ms)
            graph_start_time_ms = start_time_ms
        if (graph_end_time_ms == null || end_time_ms > graph_end_time_ms)
            graph_end_time_ms = end_time_ms

        append_to_table(analysis_table, "Activity Type", json_data["Activity Type"]);

        if (start_time_ms > 0)
            append_to_table(analysis_table, "Start Time", unix_time_ms_to_local_string(start_time_ms));
        if (end_time_ms > 0)
            append_to_table(analysis_table, "End Time", unix_time_ms_to_local_string(end_time_ms));
        if (elapsed_time > 0)
            append_to_table(analysis_table, "Elapsed Time", convert_seconds_to_hours_mins_secs(elapsed_time));
        if (distance_meters > 0)
            append_to_table(analysis_table, "Total Distance", convert_distance_to_unit_system_str(units, distance_meters));
        if (vertical_distance > 0)
            append_to_table(analysis_table, "Total Vertical Distance", convert_vertical_distance_to_unit_system_str(units, vertical_distance));
        if (json_data["Average Speed"] > 0)
            append_to_table(analysis_table, "Average Speed", convert_speed_to_unit_system_str(units, json_data["Average Speed"]));

        let bests = json_data["Bests"];

        if (bests["Best 1K"] > 0)
            append_to_table(analysis_table, "Best 1K", convert_seconds_to_hours_mins_secs(bests["Best 1K"]));
        if (bests["Best Mile"] > 0)
            append_to_table(analysis_table, "Best Mile", convert_seconds_to_hours_mins_secs(bests["Best Mile"]));
        if (bests["Best 5K"] > 0)
            append_to_table(analysis_table, "Best 5K", convert_seconds_to_hours_mins_secs(bests["Best 5K"]));
        if (bests["Best 10K"] > 0)
            append_to_table(analysis_table, "Best 10K", convert_seconds_to_hours_mins_secs(bests["Best 10K"]));
        if (bests["Best 15K"] > 0)
            append_to_table(analysis_table, "Best 15K", convert_seconds_to_hours_mins_secs(bests["Best 15K"]));
        if (bests["Best Half Marathon"] > 0)
            append_to_table(analysis_table, "Best Half Marathon", convert_seconds_to_hours_mins_secs(bests["Best Half Marathon"]));
        if (bests["Best Marathon"] > 0)
            append_to_table(analysis_table, "Best Marathon", convert_seconds_to_hours_mins_secs(bests["Best Marathon"]));

        if (json_data["Maximum Power"] > 0)
            append_to_table(analysis_table, "Maximum Power", json_data["Maximum Power"].toFixed(2).toString() + " watts");
        if (json_data["Average Power"] > 0)
            append_to_table(analysis_table, "Average Power", json_data["Average Power"].toFixed(2).toString() + " watts");
        if (json_data["5 Second Power"] > 0)
            append_to_table(analysis_table, "5 Second Power", json_data["5 Second Power"].toFixed(2).toString() + " watts");
        if (json_data["12 Minute Power"] > 0)
            append_to_table(analysis_table, "12 Minute Power", json_data["12 Minute Power"].toFixed(2).toString() + " watts");
        if (json_data["20 Minute Power"] > 0)
            append_to_table(analysis_table, "20 Minute Power", json_data["20 Minute Power"].toFixed(2).toString() + " watts");
        if (json_data["1 Hour Power"] > 0)
            append_to_table(analysis_table, "1 Hour Power", json_data["1 Hour Power"].toFixed(2).toString() + " watts");
        if (json_data["Normalized Power"] > 0)
            append_to_table(analysis_table, "Normalized Power\u00ae", json_data["Normalized Power"].toFixed(2).toString() + " watts");
        if (json_data["Maximum Cadence"] > 0)
            append_to_table(analysis_table, "Maximum Cadence", json_data["Maximum Cadence"].toFixed(2).toString() + " rpm");
        if (json_data["Average Cadence"] > 0)
            append_to_table(analysis_table, "Average Cadence", json_data["Average Cadence"].toFixed(2).toString() + " rpm");
        if (json_data["Maximum Heart Rate"] > 0)
            append_to_table(analysis_table, "Maximum Heart Rate", json_data["Maximum Heart Rate"].toFixed(2).toString() + " bpm");
        if (json_data["Average Heart Rate"] > 0)
            append_to_table(analysis_table, "Average Heart Rate", json_data["Average Heart Rate"].toFixed(2).toString() + " bpm");

        if (bests["Best Mile"] > 0)
            draw_bar_chart(normalize_split_times(json_data["Mile Splits"]), "Split Times (Seconds / Mile)", "Time", "LightSteelBlue");
        if (bests["Best 1K"] > 0)
            draw_bar_chart(normalize_split_times(json_data["KM Splits"]), "Split Times (Seconds / KM)", "Time", "Tomato");

        let times = json_data["Times"];
        let speed_times = json_data["Speed Times"];
        let speeds = json_data["Speeds"];
        let power = json_data["Power Readings"];
        let power_times = json_data["Power Times"];
        let cadence = json_data["Cadence Readings"];
        let cadence_times = json_data["Cadence Times"];
        let hr = json_data["Heart Rate Readings"];
        let hr_times = json_data["Heart Rate Times"];
        let altitude = json_data["Altitude Readings"];
        let gradients = json_data["Gradient Curve"];
        let latitudes = json_data["Latitude Readings"];
        let longitudes = json_data["Longitude Readings"];
        let intervals = json_data["Intervals"];
        let power_intervals = json_data["Power Intervals"];
        let temp_readings = json_data["Temperature Readings"];
        let temp_times = json_data["Temperature Times"];
        let swim_strokes = json_data["Swim Stroke Readings"];
        let events = json_data["Events"];

        let speed_graph_colors = [ "DodgerBlue", "DarkSlateBlue" ];
        let pace_graph_colors = [ "DodgerBlue", "DarkSlateBlue" ];
        let power_colors = [ "Navy", "Indigo" ];
        let cadence_colors = [ "Tan", "DarkOrange" ];
        let hr_colors = [ "Crimson", "DeepPink" ];
        let altitude_colors = [ "ForestGreen", "DarkSeaGreen" ];
        let temp_colors = [ "FireBrick", "Cyan" ];
        let graph_color_index = current_file_num % speed_graph_colors.length;

        let time_speed_data = speed_times.map(function(x, i) {
            return {"date": new Date(x), "value": speeds[i]};
        });
        let [ adjusted_time_speed_data, max_speed ] = convert_speed_graph_to_display_units(units, time_speed_data);
        let [ time_pace_data, min_pace ] = convert_speed_graph_to_pace_graph(units, time_speed_data);
        let gap_data = compute_grade_adjusted_pace(gradients, time_pace_data);

        draw_intervals_graph(graph_start_time_ms, graph_end_time_ms, intervals, "Speed Intervals", "Gray", intervals_graph);
        draw_intervals_graph(graph_start_time_ms, graph_end_time_ms, power_intervals, "Power Intervals", power_colors[graph_color_index], power_intervals_graph);

        if (max_speed > 0)
            append_to_table(analysis_table, "Maximum Speed", max_speed.toFixed(2).toString() + " " + speed_units);
        if (min_pace > 0)
            append_to_table(analysis_table, "Minimum Pace", min_pace.toFixed(2).toString() + " " + pace_units);

        speed_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, 0, null, adjusted_time_speed_data, "Speed", speed_units, speed_graph_colors[graph_color_index], fill, speed_graph);
        pace_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, 0, null, time_pace_data, "Pace", pace_units, pace_graph_colors[graph_color_index], fill, pace_graph);
        gap_pace_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, 0, null, gap_data, "Grade Adjusted Pace", pace_units, pace_graph_colors[graph_color_index], fill, gap_pace_graph);

        if (power.length > 0)
        {
            let time_power_data = power_times.map(function(x, i) {
                return {"date": new Date(x), "value": power[i]};
            });
            power_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, 0, max_power, time_power_data, "Power", "Watts", power_colors[graph_color_index], fill, power_graph);
        }
        if (cadence.length > 0)
        {
            let time_cadence_data = cadence_times.map(function(x, i) {
                return {"date": new Date(x), "value": cadence[i]};
            });
            cadence_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, 0, max_cadence, time_cadence_data, "Cadence", "rpm", cadence_colors[graph_color_index], fill, cadence_graph);
        }
        if (hr.length > 0)
        {
            let time_hr_data = hr_times.map(function(x, i) {
                return {"date": new Date(x), "value": hr[i]};
            });
            hr_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, null, max_hr, time_hr_data, "Heart Rate", "bpm", hr_colors[graph_color_index], fill, hr_graph);
        }
        if (altitude.length > 0)
        {
            let time_altitude_data = times.map(function(x, i) {
                return {"date": new Date(x), "value": altitude[i]};
            });
            altitude_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, null, null, time_altitude_data, "Altitude", "meters", altitude_colors[graph_color_index], fill, altitude_graph);
        }
        if (temp_readings.length > 0)
        {
            let time_temp_data = temp_times.map(function(x, i) {
                return {"date": new Date(x), "value": temp_readings[i]};
            });
            temp_graph = draw_graph(graph_start_time_ms, graph_end_time_ms, null, null, time_temp_data, "Temperature", "C", temp_colors[graph_color_index], fill, temp_graph);
        }
        if (swim_strokes.length > 0)
        {
            draw_bar_chart(swim_strokes, "Total Strokes", "Strokes", "LightSteelBlue");
        }
        if (events.length > 0 && times.length > 0)
        {
            let new_events = events.map(function(event, i) {
                let timestamp = event["timestamp_ms"];
                let time_index = times.findIndex(function(val) { return val == timestamp; }, timestamp);

                if (time_index != -1)
                {
                    return [ latitudes[time_index], longitudes[time_index], event["event_type"] ];
                }
                return [ latitudes[0], longitudes[0], event["event_type"] ];
            });
            events = new_events;
        }

        if (latitudes.length > 0)
        {
            draw_map(latitudes, longitudes, map_color, distance_meters, events);
        }

        // Show the export section, which may be configured differently depending on whether or not we're analyzing multiple files.
        let section = document.getElementById("export");
        section.style = "display: block;";
        if (total_num_files > 1)
        {
            let export_button = document.getElementById("export_button");
            export_button.textContent = "Merge";
            let export_style = document.getElementById("export_style");
            export_style.style = "display: none;";
        }
        current_file_num = current_file_num + 1;
    }

    window.clear_graph_data = function clear_graph_data()
    {
        reports = [];
        current_file_num = 0;

        intervals_graph = null;
        power_intervals_graph = null;
        speed_graph = null;
        pace_graph = null;
        gap_pace_graph = null;
        power_graph = null;
        cadence_graph = null;
        hr_graph = null;
        altitude_graph = null;
        temp_graph = null;

        graph_start_time_ms = null;
        graph_end_time_ms = null;
        max_power = null;
        max_cadence = null;
        max_hr = null;
        max_altitude = null;
    }

    window.analyze_file_data = function analyze_file_data(name, ext, blob, file_num, num_files_selected)
    {
        let report = "";

        if (ext.toLowerCase() == "gpx")
        {
            report = analyze_gpx(blob);
        }
        else if (ext.toLowerCase() == "tcx")
        {
            report = analyze_tcx(blob);
        }
        else if (ext.toLowerCase() == "fit")
        {
            let raw = new Uint8Array(blob);
            report = analyze_fit(raw);
        }
        else
        {
            alert("Unrecognized file extension. Must be tcx, gpx, or fit.");
            return;
        }

        if (report.length == 0)
        {
            return;
        }

        // The data is returned as a JSON string.
        let json_data = JSON.parse(report);

        // Add it to our collection of reports awaiting rendering.
        reports.push(json_data);

        // Once all the files have been processed then render them all at once.
        // We need to do it like this so we can find the total extent (i.e. start time and end time)
        // for the purpose of drawing the graphs correctly.
        if (file_num == num_files_selected)
        {
            // Find the start and end time.
            for (let i = 1; i <= reports.length; i++)
            {
                find_graph_extents(reports[i-1]);
            }

            // Render.
            for (let i = 1; i <= reports.length; i++)
            {
                render(reports[i-1], i, num_files_selected);
            }
        }
    }

    function create_download_link(data, filename, type)
    {
        let file = new Blob([data], { type: type });
        let downloads_div = document.getElementById('downloads');
        let a = document.createElement("a");
        let url = URL.createObjectURL(file);

        a.href = url;
        a.text = "[" + filename + "]";
        a.id = filename;
        a.download = filename;

        downloads_div.appendChild(a);
    }

    function create_local_file(data, filename, type)
    {
        let file = new Blob([data], { type: type });

        if (window.navigator.msSaveOrOpenBlob)
        {
            window.navigator.msSaveOrOpenBlob(file, filename);
        }
        else
        {
            let a = document.createElement("a");
            let url = URL.createObjectURL(file);

            a.href = url;
            a.id = filename;
            a.download = filename;
            document.body.appendChild(a);
            a.click();

            setTimeout(function() {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);  
            }, 0); 
        }
    }

    function isNumber(n)
    {
        return !isNaN(n)
    }

    window.export_to_file = function export_to_file()
    {
        let export_button = document.getElementById("export_button");
        let export_format = document.getElementById('export_format').value.toLowerCase();

        if (export_button.textContent == "Merge")
        {
            let data = merge(export_format);

            create_local_file(data, "file." + export_format, "text/plain;charset=utf-8");
        }
        else
        {
            let split_offset_secs = 0;

            if (document.getElementById('export_style').value == "MultipleFiles")
            {
                let split_time_value = document.getElementById('split_time').value;

                if (isNumber(split_time_value))
                {
                    split_offset_secs = Number(split_time_value);
                }
            }

            if (split_offset_secs > 0)
            {
                let data1 = export_data(export_format, 0, split_offset_secs);
                let data2 = export_data(export_format, split_offset_secs, 0);

                create_download_link(data1, "file1." + export_format, "text/plain;charset=utf-8");
                create_download_link(data2, "file2." + export_format, "text/plain;charset=utf-8");
            }
            else
            {
                let data = export_data(export_format, 0, 0);

                create_local_file(data, "file." + export_format, "text/plain;charset=utf-8");
            }
        }
    }

    run();
</script>

<section class="settings">
    <div>
        <h1>Select a File</h1>
        <input type="file" id="file_picker" class="modern_button" accept=".gpx,.tcx,.fit" name="file_picker" multiple>
        <button type="button" class="modern_button" onclick="return analyze_selected_files()">Analyze File(s)</button><br>
        <select id="units" onchange="on_units_changed()">
            <option value="Metric">Metric</option>
            <option value="Standard">Standard</option>
        </select>
        <h4>Analyze, compare, split, and merge fitness files.<br>Only GPX, TCX, and FIT files are supported.<br>Power and cadence data are only read from TCX and FIT files.</h4>
    </div>
</section>

<section class="settings" id="export" style="display: none;">
    <div>
        <select id="export_format" onchange="on_export_format_changed()">
            <option value="GPX">GPX</option>
            <option value="TCX">TCX</option>
        </select><br>
        <select id="export_style" onchange="on_export_style_changed()">
            <option value="SingleFile">Single File</option>
            <option value="MultipleFiles">Multiple Files</option>
        </select><br>
        <div id="export_splits" style="display: none;">
            <p>
            Split at <input type="number" id="split_time" name="split_time" min="1"> seconds from the start of the activity
            </p>
        </div>
        <button id="export_button" type="button" class="modern_button" onclick="return window.export_to_file()">Export</button>
        <div id="downloads">
            <p></p>
        </div>
    </div>
</section>

<section class="analysis" id="analysis_section">
</section>

<section class="charts">
    <div id="charts"/>
</section>

<div id="map_canvas" class="map_canvas" style="display: none;">

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/openlayers/2.13.1/OpenLayers.js" integrity="sha256-/SzuLhIQJr2lXrXlvjX3aLOEEt2UkhqSc8mmYblwqwc=" crossorigin="anonymous"></script>
<script type="text/javascript" src="../js/OpenStreetMap.js"></script>
<script type="text/javascript">
    let map = new OpenLayers.Map();

    /// @function clear_map
    function clear_map()
    {
        $('#map_canvas').empty();
        map = new OpenLayers.Map();
    }

    /// @function draw_map
    function draw_map(latitudes, longitudes, line_color, extent_meters, events)
    {
        let map_div = document.getElementById('map_canvas');
        map_div.style = "display: block;";

        let osm_layer = new OpenLayers.Layer.OSM("OSM");
        map.addLayer(osm_layer);

        let projection = new OpenLayers.Projection("EPSG:4326");
        let project_to = map.getProjectionObject(); // The map projection (Spherical Mercator)

        if (events.length > 0)
        {
            let marker_color_list = ["red", "black"];
            let marker_layer_name = [events[0][2]];
            let marker_style_array = [new OpenLayers.StyleMap({ pointRadius: 6, fillColor: marker_color_list[0], fillOpacity: 0.5 })];
            let marker_vector_layer = [new OpenLayers.Layer.Vector(marker_layer_name[0], { styleMap: marker_style_array[0] })];

            let j = 0;
            for (var i = 1; i < events.length; i++)
            {
                if (!marker_layer_name.includes(events[i][2]))
                {
                    j++;
                    marker_layer_name.push(events[i][2]); // If new layer name found it is created
                    marker_style_array.push(new OpenLayers.StyleMap({ pointRadius: 6, fillColor: marker_color_list[j % marker_color_list.length], fillOpacity: 0.5 }));
                    marker_vector_layer.push(new OpenLayers.Layer.Vector(marker_layer_name[j], { styleMap: marker_style_array[j] }));
                }
            }

            for (var i = 0; i < events.length; i++)
            {
                let marker_lat = events[i][0];
                let marker_lon = events[i][1];
                let feature = new OpenLayers.Feature.Vector(
                    new OpenLayers.Geometry.Point(marker_lon, marker_lat).transform(projection, project_to), { description: "marker number " + i });
                marker_vector_layer[marker_layer_name.indexOf(events[i][2])].addFeatures(feature);
            }

            for (var i = 0; i < marker_layer_name.length; i++) {
                map.addLayer(marker_vector_layer[i]);
            }
        }

        let points = new Array();
        latitudes.map(function(e, i) {
            points.push(new OpenLayers.Geometry.Point(longitudes[i], e));
        });

        let my_line = new OpenLayers.Geometry.LineString(points).transform(projection, map.getProjectionObject());
        let my_line_style = { strokeColor: line_color, strokeWidth: 3, strokeOpacity: 0.75 };
        let my_feature = new OpenLayers.Feature.Vector(my_line, {}, my_line_style);
        let my_vector = new OpenLayers.Layer.Vector("line test");

        my_vector.addFeatures([my_feature]);
        map.addLayers([my_vector]);

        let lon = longitudes[0];
        let lat = latitudes[0];
        let lon_lat = new OpenLayers.LonLat(lon, lat).transform(projection, map.getProjectionObject());
        let zoom = 17.0 - (extent_meters / 10000.0);

        if (zoom < 10.0)
            zoom = 10.0;
        map.setCenter(lon_lat, zoom);
        map.render(map_div);
    }
</script>

</div>

<!-- Scripts for loading the file and drawing the graphs -->
<script type="text/javascript">

    var selected_file_list = [];
    var file_picker = document.getElementById('file_picker');

    /// @function clear_analysis_summary
    function clear_analysis_summary()
    {
        let analysis_section = document.getElementById('analysis_section');
        analysis_section.innerHTML = '';
    }

    /// @function clear_all_graphs
    function clear_all_graphs()
    {
        window.clear_graph_data();
        $('#charts').empty();
    }

    /// @function draw_graph
    // if existing_graph is provided, a new line will be appended to that graph.
    function draw_graph(graph_start_time_ms, graph_end_time_ms, min_y, max_y, data, title, units, color, fill, existing_graph)
    {
        if (data.length <= 1)
        {
            return;
        }

        let draw_y_axis = existing_graph == null || min_y == null || max_y == null;
        let first_point = data[0];
        let last_point = data[data.length - 1];
        let last_ts = last_point["date"].getTime();

        // If the y axis extents were not provided then calculate them now.
        if (min_y == null)
            min_y = d3.min(data, function(d) { return d.value; }) * 0.9;
        if (max_y == null)
            max_y = d3.max(data, function(d) { return d.value; });

        // Need the graphs to start at zero or the fill will look stupid.
        graph_node = {};
        graph_node["date"] = new Date(first_point["date"] - 1);
        graph_node["value"] = 0.0;
        data.unshift(graph_node);

        // To make all the graphs line up, make sure they have the same start and end time.
        if (graph_start_time_ms > 0)
        {
            graph_node = {};
            graph_node["date"] = new Date(graph_start_time_ms);
            graph_node["value"] = 0.0;
            data.unshift(graph_node);
        }

        // Need the graphs to start at zero or the fill will look stupid.
        graph_node = {};
        graph_node["date"] = new Date(last_ts + 1);
        graph_node["value"] = 0.0;
        data.push(graph_node);

        if (graph_end_time_ms >= last_ts)
        {
            graph_node = {};
            graph_node["date"] = new Date(graph_end_time_ms);
            graph_node["value"] = 0.0;
            data.push(graph_node);
        }

        let tooltip = d3.select("#charts")
            .append("div")
                .style("opacity", 0)
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background-color", "white")
                .style("z-index", 1)
                .style("cursor", "pointer")
        let mouseover = function() {
            tooltip
                .style("opacity", 0.7)
                .style("visibility", "visible")
        }
        let mousemove = function() {
            let coordinates = d3.mouse(this);
            let x = coordinates[0];

            if (x < data.length)
            {
                tooltip
                    .html("<b>" + data[x].value.toFixed(2) + " " + units + "</b>")
                    .style("top", (event.pageY)+"px")
                    .style("left", (event.pageX)+"px")
            }
        }
        let mouseleave = function() {
        }

        let margin = { top: 20, right: 20, bottom: 20, left: 50 },
            width = $("#charts").width() - margin.left - margin.right,
            height = 250 - margin.top - margin.bottom;

        let svg = existing_graph;

        // Create the x axis scale function, which is in date format.
        let x_scale = d3.scaleTime()
            .domain(d3.extent(data, function(d) { return d.date; }))
            .range([ 0, width ]);

        // Create the y axis.
        let y_scale = d3.scaleLinear()
            .domain([ min_y, max_y ])
            .range([ height, 0 ]);

        if (existing_graph == null)
        {
            // Create the graph.
            svg = d3.select("#charts")
                .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .on('mouseover', mousemove)
                    .on('mousemove', mouseover)
                    .on('mouseleave', mouseleave)
                .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create and add the grid lines.
            let x_axis_grid = d3.axisBottom(x_scale)
                .tickSize(-height)
                .tickSizeOuter(0)
                .tickFormat('')
                .ticks(10);
            let y_axis_grid = d3.axisLeft(y_scale)
                .tickSize(-width)
                .tickSizeOuter(0)
                .tickFormat('')
                .ticks(10);
            svg.append('g')
                .attr('class', 'x axis-grid')
                .attr('transform', 'translate(0,' + height + ')')
                .call(x_axis_grid);
            svg.append('g')
                .attr('class', 'y axis-grid')
                .call(y_axis_grid);

            // Add the x axis.
            let x_axis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x_scale));

            // If the user double clicks, re-initialize the chart.
            svg.on("dblclick", function() {
                x_scale.domain(d3.extent(data, function(d) { return d.date; }))
                x_axis.transition().call(d3.axisBottom(x_scale))
                line.select('.line')
                    .transition()
                    .attr("d", d3.line()
                        .x(function(d) { return x_scale(d.date) })
                        .y(function(d) { return y_scale(d.value) }));
            });

            // Add the title.
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - (margin.left))
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text(title);

            // Add a clipPath: everything out of this area won't be drawn.
            let clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip")
                .append("svg:rect")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("x", 0)
                    .attr("y", 0);

            // A function that set idle_time_out to null.
            var idle_time_out;
            function idled() { idle_time_out = null; }

            // A function that update the chart for given boundaries.
            function update_chart()
            {
                // What are the selected boundaries?
                let extent = d3.event.selection;

                // If no selection, back to initial coordinate. Otherwise, update x axis domain.
                if (extent)
                {
                    x_scale.domain([ x_scale.invert(extent[0]), x_scale.invert(extent[1]) ]);
                    line.select(".brush").call(brush.move, null); // This removes the grey brush area as soon as the selection has been done.
                }
                else
                {
                    if (!idle_time_out)
                        return idle_time_out = setTimeout(idled, 350); // This allows to wait a little bit.
                    x_scale.domain([4,8])
                }

                // Update the axis and line position.
                x_axis.transition().duration(1000).call(d3.axisBottom(x_scale));
                line.select('.line')
                    .transition()
                    .duration(1000)
                    .attr("d", d3.line()
                        .x(function(d) { return x_scale(d.date) })
                        .y(function(d) { return y_scale(d.value) }));
            }
        }

        // Add the y axis.
        let y_axis = null;
        if (draw_y_axis)
        {
            if (existing_graph == null)
            {
                y_axis = svg.append("g")
                    .call(d3.axisLeft(y_scale));
            }
            else
            {
                y_axis = svg.append("g")
                    .call(d3.axisRight(y_scale));
            }
        }

        // Create the line.
        let line = svg.append('g')
            .attr("clip-path", "url(#clip)");

        // Add the line.
        let fill_color = "none";
        if (fill)
            fill_color = color;
        line.append("path")
            .datum(data)
            .attr("class", "line")  // I add the class line to be able to modify this line later on.
            .attr("fill", fill_color)
            .attr("stroke", color)
            .attr("stroke-width", 0.25)
            .attr("d", d3.line()
                .x(function(d) { return x_scale(d.date) })
                .y(function(d) { return y_scale(d.value) }));

        // Add the brushing.
        let brush = d3.brushX()                        // Add the brush feature using the d3.brush function.
            .extent( [ [ 0, 0 ], [ width, height ] ] ) // Initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area.
            .on("end", update_chart)                   // Each time the brush selection changes, trigger the 'update_chart' function.
        line.append("g")
            .attr("class", "brush")
            .call(brush);

        return svg;
    }

    /// @function draw_bar_chart
    function draw_bar_chart(data, title, units, color)
    {
        let tooltip = d3.select("#charts")
            .append("div")
                .style("opacity", 0)
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background-color", "white")
                .style("z-index", 1)
                .style("cursor", "pointer")
        let mouseover = function() {
            tooltip
                .style("opacity", 0.7)
                .style("visibility", "visible")
        }
        let mousemove = function() {
            let coordinates = d3.mouse(this);
            let x = Math.floor((coordinates[0] / width) * data.length);

            if (x < data.length)
            {
                let value = data[x];

                if (units == "Time")
                    value = convert_seconds_to_hours_mins_secs(value);
                tooltip
                    .html("<b>" + value + "</b>")
                    .style("top", (event.pageY) + "px")
                    .style("left", (event.pageX) + "px")
            }
        }
        let mouseleave = function() {
        }

        let margin = { top: 20, right: 20, bottom: 55, left: 50 },
            width = $("#charts").width() - margin.left - margin.right,
            height = 250 - margin.top - margin.bottom;

        let x = d3.scaleBand().domain(d3.range(1, data.length + 1)).range([0, width])
        let y = d3.scaleLinear().domain([0, d3.max(data)]).range([height, 0])

        let x_axis = d3.axisBottom(x);
        let y_axis = d3.axisLeft(y).ticks(2);

        let svg = d3.select("#charts")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .on('mouseover', mousemove)
                .on('mousemove', mouseover)
                .on('mouseleave', mouseleave)
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(title);
        svg.append("g")
            .attr("class", "y axis")
            .call(y_axis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("dy", ".71em")
            .style("text-anchor", "end");
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));
        svg.selectAll("bar")
            .data(data)
            .enter().append("rect")
            .style("fill", color)
            .attr("width", x.bandwidth())
            .attr("height", function(d) { return height - y(d); })
            .attr("x", function(d, i) { return x(i+1); })
            .attr("y", function(d) { return y(d); });
    }

    /// @function draw_intervals_graph
    function draw_intervals_graph(graph_start_time_ms, graph_end_time_ms, interval_data, title, color, existing_graph)
    {
        interval_graph = [];

        if (interval_data.length > 0)
        {
            for (let i in interval_data)
            {
                let interval = interval_data[i];
                let start_interval_time = interval.start_time;
                let end_interval_time = interval.end_time;

                graph_node = {};
                graph_node["date"] = new Date(start_interval_time - 1000);
                graph_node["value"] = 0;
                interval_graph.push(graph_node);
                graph_node = {};
                graph_node["date"] = new Date(start_interval_time);
                graph_node["value"] = 1;
                interval_graph.push(graph_node);
                graph_node = {};
                graph_node["date"] = new Date(end_interval_time);
                graph_node["value"] = 1;
                interval_graph.push(graph_node);
                graph_node = {};
                graph_node["date"] = new Date(end_interval_time + 1000);
                graph_node["value"] = 0;
                interval_graph.push(graph_node);
            }

            draw_graph(graph_start_time_ms, graph_end_time_ms, 0, 1, interval_graph, title, "", color, true, existing_graph);
        }
    }

    /// @function analyze_selected_files
    function analyze_selected_files()
    {
        let file_num = 0;

        if (selected_file_list.length > 0)
        {
            clear_analysis_summary();
            clear_all_graphs();
            clear_map();

            for (var i = 0; i < selected_file_list.length; i++)
            {
                let selected_file_obj = selected_file_list[i];
                let reader = new FileReader();
                let ext = selected_file_obj.name.split('.').pop();

                reader.onerror = function(event)
                {
                    reader.abort();
                };
                reader.onload = function(e)
                {
                    window.analyze_file_data(selected_file_obj.name, ext, reader.result, ++file_num, selected_file_list.length);

                    // If we've processed the last file then clear the file list, in case the user loads more files without refreshing the page.
                    if (file_num == selected_file_list.length)
                    {
                        selected_file_list = [];
                    }
                }

                if ((ext.toLowerCase() == "gpx") || (ext.toLowerCase() == "tcx"))
                {
                    reader.readAsText(selected_file_obj);
                }
                else if (ext.toLowerCase() == "fit")
                {
                    reader.readAsArrayBuffer(selected_file_obj);
                }
                else
                {
                    alert("Unrecognized file extension. Must be tcx, gpx, or fit.");
                    return;
                }
            }
        }
        else
        {
            alert("A file was not specified.");
        }
    }

    /// @function get_cookie
    function get_cookie(cookie_name)
    {
        let name = cookie_name + "=";
        let decoded_cookie = decodeURIComponent(document.cookie);
        let ca = decoded_cookie.split(';');

        for (let i = 0; i < ca.length; i++)
        {
            let c = ca[i];

            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }

    $(document).ready(function()
    {
        // Add the on change listener for the file picker.
        file_picker.addEventListener('change', e => {
            for (let file of Array.from(e.target.files))
            {
                selected_file_list.push(file);
            };
        });

        // Set the preferred units.
        let units = get_cookie("units");
        if (units.length == 0)
            document.getElementById('units').value = "Metric";
        else
            document.getElementById('units').value = units;

        // Set the preferred export format.
        let export_format = get_cookie("export_format");
        if (export_format.length == 0)
            document.getElementById('export_format').value = "GPX";
        else
            document.getElementById('export_format').value = export_format;
    });

</script>

<!--
<section class="connections">
    <div>
        <h1>Connected Services</h1>
        <a href="api/connect_to_strava"><img src="../images/connect_to_strava.png" width="256"></a>
    </div>
</section>
-->

<section class="faq">
    <div>
        <h1>Frequently Asked Questions</h1>
        <ul>
            <li>What does this do? <p>It gives you the ability to analyze, compare, split, or merge tcx, gpx, and fit files.</p>
            <li>How much does this cost? <p>Nothing</p>
            <li>How does it work? <p>This page is a combination of HTML, Javascript, CSS, and WebAssembly compiled from Rust.</p>
            <li>What data do you store? <p>Nothing. All processing is done in the browser. No data leaves the local machine.</p>
            <li>Can I connect this to Strava, etc.? <p>Not right now, but maybe in the future.</p>
            <li>Can I see the source code? <p>Yes, it is available on <a href="https://github.com/msimms/ActivityAnalyzer">GitHub</a>.</p>
            <li>Is there any documentation? <p>Though this page is fairly self-explanatory, there is more documentation <a href="https://github.com/msimms/ActivityAnalyzer/wiki">on the GitHub wiki page</a>.</p>
        </ul>
    </div>
</section>

<section class="faq">
    <div>
        <h1>Troubleshooting</h1>
        <ul>
            <li>The map doesn't render when using the Safari browser <p>Safari has strict cross origin protections that prevent the map data from another domain.</p>
        </ul>
    </div>
</section>

<section class="footer">
    <div>
        <h2>Copyright (c) 2021 Michael J Simms</h2>
    </div>
</section>

</body>

</html>
